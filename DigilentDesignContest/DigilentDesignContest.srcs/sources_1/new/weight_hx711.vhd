----------------------------------------------------------------------------------
-- Company: 
-- Engineer: 
-- 
-- Create Date:    09:30:06 04/20/2017 
-- Design Name: 
-- Module Name:    hx711 - a_hx711 
-- Project Name: 
-- Target Devices: 
-- Tool versions: 
-- Description: 
--
-- Dependencies: 
--
-- Revision: 
-- Revision 0.01 - File Created
-- Additional Comments: 
--
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity hx711 is
	port( clk          : in std_logic;
			DOUT       : in std_logic;			--data from the hx711 module(24 bits, one by one starting with the MSB)
			SCK        : out std_logic;
			final_data :out std_logic_vector(11 downto 0));		--clock generated by us with a frequency of 500KHz (T = 2 us)

end hx711;


architecture a_hx711 of hx711 is

type states is (INIT, START, WAIT_BEFORE_READ, READ_DATA);
signal state: states;

signal count_wait: std_logic_vector(3 downto 0) := (others => '0');
signal count_read: std_logic_vector(12 downto 0) := (others => '0'); --count to 6250 (25 * 100 ns == 25 * ( 50 high + 50 low))

signal data : std_logic_vector(23 downto 0);
signal shift: std_logic := '0';

signal en_cnt_125, rst_cnt_125: std_logic := '0'; --count_125 used to make the 500KHz clock divider: it counts until 125 ( 125MHz / 500 Khz = 250)
signal clock_500KHz: std_logic :=  '0';         --==> 125 clock pulses = HIGH, 125 clock pulses == LOW 
signal count_125 : std_logic_vector(6 downto 0) := (others => '0');

signal falling_edge_500KHz: std_logic_vector(1 downto 0) := (others => '0');
begin
	
	process(clk, state, DOUT)
	begin
		if rising_edge(clk) then
			rst_cnt_125 <= '0';
			en_cnt_125 <= '0';
			
			case state is
				when INIT => if DOUT = '0' then
									state <= START;
								else
									state <= INIT;
								end if;
								
				when START => if DOUT = '0' then 
									state <= WAIT_BEFORE_READ;
								  else
									state <= INIT;	
								  end if;
								  
				when WAIT_BEFORE_READ => if DOUT = '1' then -- error => DOUT should be LOW 
                                            state <= INIT;
                                         elsif count_wait = 12 then 
                                            state <= READ_DATA;
                                            count_wait <= (others => '0');
                                         else
                                            state <= WAIT_BEFORE_READ;
                                            count_wait <= count_wait + 1;
                                         end if;
												
	         when READ_DATA => if count_read = 6250 then --if count_read = 6250
                                    state <= INIT;
                                    final_data <= data(23 downto 12) ;
                                    count_read <= (others => '0');
                                    rst_cnt_125 <= '1';
                                else
                                    state <= READ_DATA;
                                    count_read <= count_read + 1;
                                    en_cnt_125 <= '1';
                                end if;
			end case;
		end if;
	end process;
	
	
	process(state, clock_500KHz)
	begin
		case state is
			when INIT => shift <= '0';
							 SCK <= '0';
			when START => shift <= '0';
							  SCK <= '0';
			when WAIT_BEFORE_READ => shift <= '0';
							         SCK <= '0';
			when READ_DATA => shift <= '1';
							 SCK <= clock_500KHz;
		end case;
	end process;


	
	process(clk, en_cnt_125, rst_cnt_125, count_125, clock_500KHz)
	begin
	if rst_cnt_125 = '1' then
		count_125 <= (others => '0');
		clock_500KHz <= '0';
		falling_edge_500KHz <= (others => '0');
		
	elsif rising_edge(clk) then
			if en_cnt_125 = '1' then
				if count_125 = 125 then -- if counter = 50
					count_125 <= conv_std_logic_vector(1, 7);-- counter will have the value 1
					
					if clock_500KHz = '1' then
						falling_edge_500KHz <= '1' & falling_edge_500KHz(1);
					else
						falling_edge_500KHz <= '0' & falling_edge_500KHz(1);
					end if;
					
					clock_500KHz <= not clock_500KHz;
					
				else
					falling_edge_500KHz <= '0' & falling_edge_500KHz(1);
					count_125 <= count_125 + 1;
				end if;
			end if;
	end if;
	end process;
	
	
	process(clk, shift, falling_edge_500KHz, DOUT)
	begin
		if rising_edge(clk) then
			if shift = '1' and falling_edge_500KHz = "10" then
				data <= data(22 downto 0) & DOUT;
			end if;
		end if;
	end process;
end a_hx711;